import calendar
import math
import re
from datetime import date, timedelta

from odoo import _, fields, models
from odoo.exceptions import UserError

FEE_PATERN = re.compile("^fees?\s*:", flags=re.IGNORECASE)


class CryptoTransactionDetail(models.Model):
    _name = "crypto.transaction.detail"
    _description = "Cryptocurrency Transaction Detail"

    transaction_id = fields.Many2one("crypto.transaction", string="Master Transaction", readonly=True)

    name = fields.Char("Label", readonly=True)
    date = fields.Datetime("Date", readonly=True)
    description = fields.Char("Description", readonly=True)
    address = fields.Char("Address", readonly=True)
    currency_id = fields.Many2one("res.currency", string="Currency", readonly=True)
    value = fields.Monetary("Value", currency_field="currency_id", readonly=True)

    state = fields.Selection(
        [("ready", "Ready"), ("done", "Done"), ("ignored", "Ignored")],
        string="State",
        default="ready",
        readonly=True,
    )
    statement_line_ids = fields.One2many(
        "account.bank.statement.line",
        "crypto_transaction_id",
        string="Statement Lines",
        readonly=True,
    )
    bank_account_id = fields.Many2one(
        "res.partner.bank",
        string="Wallet",
        related="transaction_id.bank_account_id",
        store=True,
    )

    def create(self, vals):
        res = super().create(vals)
        if "state" in vals:
            self.transaction_id._recompute_state()
        return res

    def write(self, vals):
        res = super().write(vals)
        if "state" in vals:
            self.transaction_id._recompute_state()
        return res

    def generate_statements(self, group_by=None):
        self = self.filtered(lambda x: x.state == "ready")

        statements = self._generate_statement_lines(group_by)
        statements = self._slit_statements(statements)
        statements = self._clean_statements(statements)

        ids = []
        for statement in statements:
            ids.append(self.env["account.bank.statement"].create(statement).id)

            # recompute balances

        return {
            "type": "ir.actions.act_window",
            "name": _("Generated Statements"),
            "res_model": "account.bank.statement",
            "domain": [("id", "in", ids)],
            "view_mode": "tree,form",
        }

    def _generate_statement_lines(self, group_by=None):
        journals = {
            (j.bank_account_id.id, j.currency_id.id): j
            for j in self.env["account.journal"].search(
                [
                    ("type", "=", "bank"),
                    ("bank_statements_source", "=", "crypto"),
                ]
            )
        }
        statements = {}

        for tx in self:
            # Statements are generated by wallet and by currency
            jkey = tx.transaction_id.bank_account_id.id, tx.currency_id.id

            if jkey not in journals:
                raise UserError(
                    _("No journal found for account {acc} and currency {ccy}.").format(
                        acc=tx.transaction_id.bank_account_id.acc_number,
                        ccy=tx.currency_id.name,
                    )
                )

            if not group_by:
                period = None
            elif group_by == "week":
                period = tx.date.isocalendar()[:2]
            elif group_by == "month":
                period = tx.date.month, tx.date.year
            elif group_by == "year":
                period = tx.date.year

            journal = journals[jkey]
            skey = journal.id, period

            if skey not in statements:
                # Init statement
                statements[skey] = {
                    "_period": period,
                    "name": "{} - {}".format(
                        journal.bank_account_id.bank_name or journal.bank_account_id.acc_number,
                        journal.currency_id.name,
                    ),
                    "journal_id": journal,
                    "line_ids": [],
                    "balance_start": 0,
                    "balance_end_real": 0,
                }

            statement = statements[skey]
            line = {
                "date": tx.date,
                "payment_ref": tx.name,
                # "ref": "",
                "narration": tx.description,
                "amount": tx.value,
                "account_number": tx.address,
                "crypto_transaction_id": tx.id,
            }

            partner = tx.get_partner()
            if partner:
                line["partner_id"] = partner.id

            statement["line_ids"].append((0, 0, line))

        self.state = "done"
        return list(statements.values())

    def _slit_statements(self, statements):
        LINES_LIMIT = int(self.env["ir.config_parameter"].sudo().get_param("crypto_sync.statement_lines_limit", 0))

        if not LINES_LIMIT:
            return list(statements.values())

        new_statements = []

        for statement in statements:
            statement["_total"] = math.ceil(len(statement["line_ids"]) / LINES_LIMIT)
            statement["line_ids"] = sorted(statement["line_ids"], key=lambda x: x[2]["date"])

            for i in range(statement["_total"]):
                new_statement = statement.copy()
                new_statement["_part"] = i + 1
                new_statement["line_ids"] = statement["line_ids"][i * LINES_LIMIT : (i + 1) * LINES_LIMIT]
                new_statements.append(new_statement)

        return new_statements

    def _clean_statements(self, statements, group_by=None):
        for statement in statements:
            first = min([line[2] for line in statement["line_ids"]], key=lambda l: l["date"])
            last = max([line[2] for line in statement["line_ids"]], key=lambda l: l["date"])
            if not group_by:
                if first["date"] == last["date"]:
                    statement["name"] += " - {}".format(first["date"])
                else:
                    statement["name"] += " - {}-{}".format(first["date"], last["date"])
                statement["date"] = last["date"]
            elif group_by == "week":
                statement["name"] += " - {}, Week {}".format(*statement["_period"])
                statement["date"] = date.fromisocalendar(*statement["_period"], 7)
            elif group_by == "month":
                statement["name"] += " - {} {}".format(
                    calendar.month_name[statement["_period"][0]],
                    statement["_period"][1],
                )
                statement["date"] = date(
                    statement["_period"][1] + (1 if statement["_period"][0] == 12 else 0),
                    statement["_period"][0] % 12 + 1,
                    1,
                ) - timedelta(days=1)
            elif group_by == "year":
                statement["name"] += " - {}".format(statement["_period"])
                statement["date"] = date(statement["_period"], 1, 1) - timedelta(days=1)

            part, total = statement.get("_part", 1), statement.get("_total", 1)
            if total != 1:
                statement["name"] += " ({}/{})".format(part, total)

            for key in list(statement.keys()):
                if key.startswith("_"):
                    statement.pop(key)

            statement["journal_id"] = statement["journal_id"].id
        return statements

    def get_partner(self):
        self.ensure_one()
        address = self.address
        if not address and FEE_PATERN.match(self.name):
            tx = self.transaction_id.output_ids.filtered("address").sorted("value", True)
            if not tx:
                return
            address = tx[0].address
        if not address:
            return
        bank_account = self.env["res.partner.bank"].search(
            [("acc_number", "=ilike", address)],
            limit=1,
        )
        if not bank_account:
            return
        return bank_account.partner_id

    def action_open_parent(self):
        self.ensure_one()
        return {
            "type": "ir.actions.act_window",
            "res_model": "crypto.transaction",
            "view_type": "form",
            "view_mode": "form",
            "res_id": self.transaction_id.id,
        }
